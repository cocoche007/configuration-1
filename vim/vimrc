" ======================================================================================
" File         : .vimrc
" Author       : Adrien Oliva 
" Last Change  : 12/21/2012 | 11:14:19 AM | Friday,December
" Description  : 
" ======================================================================================

" Enable ExVim
let $EX_DEV='~/.exdev'
let g:ex_toolkit_path = $HOME.'/.toolkit'

" put your own user name here
let g:ex_usr_name = "Adrien Oliva"

"/////////////////////////////////////////////////////////////////////////////
" General
"/////////////////////////////////////////////////////////////////////////////

" Use vim settings instead of Vi
set nocompatible
" always use English menu
set langmenu=none
" always use english for anything in vim-editor.
silent exec "language en_US.utf8"

" this will avoid bug in my project with namespace ex, the vim will tree ex:: as modeline.
au FileType c,cpp,cs,swig set nomodeline

" Set mouse behaviour as xterm
behave xterm

set backup " make backup file and leave it around 
"UNUSED: set backupdir=%tmp%
"UNUSED: set directory=.,%tmp%

" setup back and swap directory
let data_dir = $HOME.'/.data/'
let backup_dir = data_dir . 'backup' 
let swap_dir = data_dir . 'swap' 
if finddir(data_dir) == ''
    silent call mkdir(data_dir)
endif
if finddir(backup_dir) == ''
    silent call mkdir(backup_dir)
endif
if finddir(swap_dir) == ''
    silent call mkdir(swap_dir)
endif
set backupdir=$HOME/.data/backup " where to put backup file
set directory=$HOME/.data/swap " where to put swap file
unlet data_dir
unlet backup_dir
unlet swap_dir

" programming related
set tags+=./tags,./../tags,./**/tags,tags " which tags files CTRL-] will find
set makeef=error.err " the errorfile for :make and :grep

set viminfo+=! " make sure it can save viminfo 
filetype on " enable file type detection 
filetype plugin on " enable loading the plugin for appropriate file type 

" Redefine the shell redirection operator to receive both the stderr messages
" and stdout messages
set shellredir=>%s\ 2>&1

set history=50 " keep 50 lines of command line history
set updatetime=1000 " default = 4000
set autoread " auto read same-file change ( better for vc/vim change )

" enlarge maxmempattern from 1000 to ... (2000000 will give it without limit)
set maxmempattern=1000

set mouse=a

" -----------------------------------------------------------------------------------
"  Desc: Visual
" -----------------------------------------------------------------------------------
set showmatch   " show matching paren 
set matchtime=0 " 0 second to show the matching paren ( much faster )
set nu          " Show LineNumber
set scrolloff=0 " minimal number of screen lines to keep above and below the cursor 
set nowrap      " I don't like wrap, cause in split window mode, it feel strange

" Set color scheme
silent exec "colorscheme elflord"
set background=dark

set wildmenu " turn on wild menu, try typing :h and press <Tab> 
set showcmd	" display incomplete commands
set cmdheight=1 " 1 screen lines to use for the command-line 
set ruler " show the cursor position all the time
set hid " allow to change buffer without saving 
set shortmess=atI " shortens messages to avoid 'press a key' prompt 
set lazyredraw " do not redraw while executing macros (much faster) 
set display+=lastline " for easy browse last line with wrap text
set laststatus=2 " always have status-line

set showfulltag " show tag with function protype.
set guioptions+=b " Present the bottom scrollbar when the longest visible line exceen the window

" disable menu & toolbar
set guioptions-=m
set guioptions-=T

set encoding=utf-8
set termencoding=utf-8

" Show hiddn characters
highlight NbSp ctermbg=lightgray guibg=lightred
match NbSp /\%xa0/

set list
set lcs:trail:·,tab:»\ 

" ------------------------------------------------------------------ 
" Desc: Text edit
" ------------------------------------------------------------------ 
set ai " autoindent 
set si " smartindent 
set backspace=indent,eol,start " allow backspacing over everything in insert mode
" indent options
"  see help cinoptions-values for more details
set	cinoptions=>s,e0,n0,f0,{0,}0,^0,:0,=s,l0,b0,g0,hs,ps,ts,is,+s,c3,C0,0,(0,us,U0,w0,W0,m0,j0,)20,*30

" Official diff settings
set diffexpr=MyDiff()
function MyDiff()
    let opt = '-a --binary -w '
    if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
    if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
    let arg1 = v:fname_in
    if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
    let arg2 = v:fname_new
    if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
    let arg3 = v:fname_out
    if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
    silent execute '!' .  'diff ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3
endfunction

set cindent shiftwidth=4 " Set cindent on to autoinent when editing C/C++ file, with 4 shift width
set tabstop=4 " Set tabstop to 4 characters
set expandtab " Set expandtab on, the tab will be change to space automaticaly

" Set Number format to null(default is octal) , when press CTRL-A on number
" like 007, it would not become 010
set nf=
" In Visual Block Mode, cursor can be positioned where there is no actual character
set ve=block

" ------------------------------------------------------------------ 
" Desc: Fold text
" ------------------------------------------------------------------ 

set foldmethod=marker foldmarker={,} foldlevel=9999
set diffopt=filler,context:9999

" ------------------------------------------------------------------ 
" Desc: Search
" ------------------------------------------------------------------ 

" Switch syntax highlighting on, when the terminal has colors
" Also switch on highlighting the last used search pattern.
if &t_Co > 2 || has("gui_running")
    syntax on
    set hlsearch
endif
set incsearch " do incremental searching
set ignorecase " Set search/replace pattern to ignore case 
set smartcase " Set smartcase mode on, If there is upper case character in the search patern, the 'ignorecase' option will be override.

" set this to use id-utils for global search
set grepprg=lid\ -Rgrep\ -s
set grepformat=%f:%l:%m


"/////////////////////////////////////////////////////////////////////////////
" Key Mappings
"/////////////////////////////////////////////////////////////////////////////

" Don't use Ex mode, use Q for formatting
map Q gq  

" F8:  Set Search pattern highlight on/off
nnoremap <unique> <F8> :let @/=""<CR>

" map Ctrl-Tab to switch window
nnoremap <unique> <S-Up> <C-W><Up>
nnoremap <unique> <S-Down> <C-W><Down>
nnoremap <unique> <S-Left> <C-W><Left>
nnoremap <unique> <S-Right> <C-W><Right>

" Move in fold
noremap <unique> z<Up> zk
noremap <unique> z<Down> zj

" Easy Diff goto
noremap <unique> <C-Up> [c
noremap <unique> <C-s> [c
noremap <unique> <C-Down> ]c
noremap <unique> <C-t> ]c

" Enhance '<' '>' , do not need to reselect the block after shift it.
vnoremap <unique> « <gv
vnoremap <unique> » >gv

" Fold close & Fold open
noremap <unique> <kPlus> zo
noremap <unique> <kMinus> zc

" map Up & Down to gj & gk, helpful for wrap text edit
noremap <unique> <Up> gk
noremap <unique> <Down> gj

" map for completion see :help ins-completion for whole completions
" search tags 
inoremap <unique> <c-]> <C-X><C-]>
" search in current files, preview first. remove the original c-p
inoremap <unique> <c-p> <C-X><C-P>

" Then when you put the cursor on or in a word, press "\sw", and
" the word will be swapped with the next word.  The words may
" even be separated by punctuation (such as "abc = def").
nnoremap <unique> <silent><leader>sw "_yiw:s/\(\%#\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/<cr><c-o>

command Checkout silent exec '!p4 edit ' . fnamemodify( bufname('%'), ':p' )
command Revert silent exec '!p4 revert ' . fnamemodify( bufname('%'), ':p' )
command Add silent exec '!p4 add ' . fnamemodify( bufname('%'), ':p' )
command Delete silent exec '!p4 delete ' . fnamemodify( bufname('%'), ':p' )
command Changelist :silent !p4 change
command ShowChangelist :!p4 changes -s pending -u jwu

" ------------------------------------------------------------------ 
" Desc: Only do this part when compiled with support for autocommands.
" ------------------------------------------------------------------ 

if has("autocmd")
  " Enable file type detection.
  " Use the default filetype settings, so that mail gets 'tw' set to 72,
  " 'cindent' is on in C files, etc.
  " Also load indent files, to automatically do language-dependent indenting.
  filetype plugin indent on

  " Put these in an autocmd group, so that we can delete them easily.
  augroup vimrcEx
  au!

  " For all text files set 'textwidth' to 78 characters.
  autocmd FileType text setlocal textwidth=78

  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  autocmd BufReadPost *
	\ if line("'\"") > 0 && line("'\"") <= line("$") |
	\   exe "normal g`\"" |
	\ endif

  augroup END
endif " has("autocmd")

" ------------------------------------------------------------------ 
" Desc: Buffer
" ------------------------------------------------------------------ 

au BufNewFile,BufEnter * set cpoptions+=d " NOTE: ctags find the tags file from the current path instead of the path of currect file
au BufEnter * :syntax sync fromstart " ensure every file does syntax highlighting (full) 
au BufNewFile,BufRead *.avs set syntax=avs " for avs syntax file.

au FileType python call s:CheckIfExpandTab() " if edit python scripts, check if have \t. ( python said: the programme can only use \t or not, but can't use them together )
function s:CheckIfExpandTab()
    let has_noexpandtab = search('^\t','wn')
    let has_expandtab = search('^    ','wn')

    "
    if has_noexpandtab && has_expandtab
        let idx = inputlist ( ["ERROR: current file exists both expand and noexpand TAB, python can only use one of these two mode in one file.\nSelect Tab Expand Type:",
                    \ '1. expand (tab=space, recommended)', 
                    \ '2. noexpand (tab=\t, currently have risk)',
                    \ '3. do nothing (I will handle it by myself)'])
        let tab_space = printf('%*s',&tabstop,'')
        if idx == 1
            let has_noexpandtab = 0
            let has_expandtab = 1
            silent exec '%s/\t/' . tab_space . '/g'
        elseif idx == 2
            let has_noexpandtab = 1
            let has_expandtab = 0
            silent exec '%s/' . tab_space . '/\t/g'
        else
            return
        endif
    endif

    " 
    if has_noexpandtab == 1 && has_expandtab == 0  
        echomsg 'substitute space to TAB...'
        set noexpandtab
        echomsg 'done!'
    elseif has_noexpandtab == 0 && has_expandtab == 1
        echomsg 'substitute TAB to space...'
        set expandtab
        echomsg 'done!'
    else
        " it may be a new file
        " we use original vim setting
    endif
endfunction

" Disable auto-comment for c/cpp, lua, javascript, c# and vim-script
au FileType c,cpp,javascript set comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,f:// 
au FileType cs set comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,f:///,f:// 
au FileType vim set comments=sO:\"\ -,mO:\"\ \ ,eO:\"\",f:\"
au FileType lua set comments=f:--

"/////////////////////////////////////////////////////////////////////////////
" Plugin Configurations
"/////////////////////////////////////////////////////////////////////////////

" ------------------------------------------------------------------ 
" Desc: exUtility
" ------------------------------------------------------------------ 


" edit current vimentry
nnoremap <unique> <leader>ve :call exUtility#EditVimEntry ()<CR>

" map for quick add special comments
nnoremap <unique> <leader>ws :SEG<CR>
nnoremap <unique> <leader>wd :DEF<CR>
nnoremap <unique> <leader>we :SEP<CR>
nnoremap <unique> <leader>wc :DEC<CR>
nnoremap <unique> <leader>wh :HEADER<CR>

" F9:  Insert/Remove macro extend ("\") after all the lines of the selection
vnoremap <unique> <F9> :call exUtility#InsertRemoveExtend()<CR>

" F12: Insert '#if 0' and '#endif' between the selection
vnoremap <unique> <F12> :call exUtility#InsertIFZero()<CR>
nnoremap <unique> <F12> :call exUtility#RemoveIFZero()<CR>

" switch between edit and ex-plugin window
nnoremap <unique> <silent><Leader><Tab> :call exUtility#SwitchBuffer()<CR>

" close ex-plugin window when in edit window
nmap <unique> <silent><Leader><ESC> :call exUtility#SwitchBuffer()<CR><ESC>

" map exUtility#Kwbd(1) to \bd will close buffer and keep window
nnoremap <unique> <Leader>bd :call exUtility#Kwbd(1)<CR>

" quick highlight
nnoremap <unique> <silent> <leader>h1 :call exUtility#Highlight_Normal(1)<CR>
nnoremap <unique> <silent> <leader>h2 :call exUtility#Highlight_Normal(2)<CR>
nnoremap <unique> <silent> <leader>h3 :call exUtility#Highlight_Normal(3)<CR>
nnoremap <unique> <silent> <leader>h4 :call exUtility#Highlight_Normal(4)<CR>

vnoremap <unique> <silent> <leader>h1 :call exUtility#Highlight_Visual(1)<CR>
vnoremap <unique> <silent> <leader>h2 :call exUtility#Highlight_Visual(2)<CR>
vnoremap <unique> <silent> <leader>h3 :call exUtility#Highlight_Visual(3)<CR>
vnoremap <unique> <silent> <leader>h4 :call exUtility#Highlight_Visual(4)<CR>

nnoremap <unique> <silent> <leader>h0 :call exUtility#HighlightCancle(0)<CR>

nnoremap <unique> <silent> <Leader>0 :call exUtility#HighlightCancle(0)<CR>
nnoremap <unique> <silent> <Leader>1 :call exUtility#HighlightCancle(1)<CR>
nnoremap <unique> <silent> <Leader>2 :call exUtility#HighlightCancle(2)<CR>
nnoremap <unique> <silent> <Leader>3 :call exUtility#HighlightCancle(3)<CR>
nnoremap <unique> <silent> <Leader>4 :call exUtility#HighlightCancle(4)<CR>

" inherit
nnoremap <unique> <silent> <Leader>gv :call exUtility#ViewInheritsImage()<CR>
let g:exES_ImageViewer = '/usr/bin/mirage'

" Mark special text
let g:ex_todo_keyword = 'NOTE REF EXAMPLE SAMPLE CHECK TIPS HINT'
let g:ex_comment_lable_keyword  = 'DELME TEMP MODIFY ADD KEEPME DISABLE TEST '
let g:ex_comment_lable_keyword .= 'ERROR DEBUG CRASH DUMMY UNUSED TESTME '
let g:ex_comment_lable_keyword .= 'FIXME BUG HACK OPTME HARDCODE REFACT DUPLICATE '
let g:ex_comment_lable_keyword .= 'REDUNDANCY PATCH '

" register buffer names of plugins.
let g:ex_plugin_registered_bufnames = ["-MiniBufExplorer-","__Tag_List__","\[Lookup File\]", "\[BufExplorer\]"] 

" register filetypes of plugins.
let g:ex_plugin_registered_filetypes = ["ex_plugin","ex_project","taglist","nerdtree"] 

" default languages
let g:ex_default_langs = ['c', 'cpp', 'c#', 'javascript', 'java', 'shader', 'python', 'lua', 'vim', 'uc', 'matlab', 'wiki', 'ini', 'make', 'sh', 'batch', 'debug', 'qt', 'swig' ] 

" set exvim language map
call exUtility#AddLangMap ( 'exvim', 'javascript', ['as'] )
call exUtility#AddLangMap ( 'exvim', 'maxscript', ['ms'] )
call exUtility#AddLangMap ( 'exvim', 'lua', ['wlua'] )

" To let the extension language works correctly, you need to put toolkit/ctags/.ctags into your $HOME directory
" set ctags language map
" call exUtility#AddLangMap ( 'ctags', 'ini', ['ini'] )
" call exUtility#AddLangMap ( 'ctags', 'uc', ['uc'] )
call exUtility#AddLangMap ( 'ctags', 'maxscript', ['ms'] )

" ------------------------------------------------------------------ 
" Desc: exTagSelect
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <Leader>ts :ExtsSelectToggle<CR>
nnoremap <unique> <silent> <Leader>tg :ExtsGoDirectly<CR>
nnoremap <unique> <silent> <Leader>] :ExtsGoDirectly<CR>

let g:exTS_backto_editbuf = 0
let g:exTS_close_when_selected = 1
let g:exTS_window_direction = 'bel'

" ------------------------------------------------------------------ 
" Desc: exGlobalSearch
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <Leader>gs :ExgsSelectToggle<CR>
nnoremap <unique> <silent> <Leader>gq :ExgsQuickViewToggle<CR>
nnoremap <unique> <silent> <Leader>gg :ExgsGoDirectly<CR>
nnoremap <unique> <silent> <Leader>n :ExgsGotoNextResult<CR>
nnoremap <unique> <silent> <Leader>N :ExgsGotoPrevResult<CR>
nnoremap <unique> <Leader><S-f> :GS 

let g:exGS_backto_editbuf = 0
let g:exGS_close_when_selected = 0
let g:exGS_window_direction = 'bel'
let g:exGS_auto_sort = 1
let g:exGS_lines_for_autosort = 200

" ------------------------------------------------------------------ 
" Desc: exSymbolTable
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <Leader>ss :ExslSelectToggle<CR>
nnoremap <unique> <silent> <Leader>sq :ExslQuickViewToggle<CR>
nnoremap <unique> <silent> <Leader>sg :ExslGoDirectly<CR>
" NOTE: the / can be mapped to other script ( for example exSearchComplete ), so here use nmap instead of nnoremap 

let g:exSL_SymbolSelectCmd = 'TS'

" ------------------------------------------------------------------ 
" Desc: exJumpStack 
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <Leader>tt :ExjsToggle<CR>
nnoremap <unique> <silent> <Leader>tb :BackwardStack<CR>
nnoremap <unique> <silent> <Leader>tf :ForwardStack<CR>
nnoremap <unique> <silent> <BS> :BackwardStack<CR>

" ------------------------------------------------------------------ 
" Desc: exCscope
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <F2> :CSIC<CR>
nnoremap <unique> <silent> <Leader>ci :CSID<CR>
nnoremap <unique> <silent> <F3> :ExcsParseFunction<CR>
nnoremap <unique> <silent> <Leader>cd :CSDD<CR>
nnoremap <unique> <silent> <Leader>cc :CSCD<CR>
nnoremap <unique> <silent> <Leader>cs :ExcsSelectToggle<CR>
nnoremap <unique> <silent> <Leader>cq :ExcsQuickViewToggle<CR>

let g:exCS_backto_editbuf = 0
let g:exCS_close_when_selected = 0
let g:exCS_window_direction = 'bel'
let g:exCS_window_width = 48

" ------------------------------------------------------------------ 
" Desc: exQuickFix
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <leader>qf :ExqfSelectToggle<CR>
nnoremap <unique> <silent> <leader>qq :ExqfQuickViewToggle<CR>

let g:exQF_backto_editbuf = 0
let g:exQF_close_when_selected = 0
let g:exQF_window_direction = 'bel'

" ------------------------------------------------------------------ 
" Desc: exMacroHighlight
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <Leader>aa :ExmhSelectToggle<CR>
nnoremap <unique> <silent> <Leader>ae :ExmhHL 1 <CR>
nnoremap <unique> <silent> <Leader>ad :ExmhHL 0 <CR>

" ------------------------------------------------------------------ 
" Desc: exProject
" ------------------------------------------------------------------ 

nnoremap <unique> <leader>ff :EXProject<CR>:redraw<CR>/\[\l*\]\zs.*
nnoremap <unique> <leader>fd :EXProject<CR>:redraw<CR>/\[\u\]\zs.*
nnoremap <unique> <leader>fc :ExpjGotoCurrentFile<CR>

let g:exPJ_backto_editbuf = 1
let g:exPJ_close_when_selected = 0
let g:exPJ_window_width = 30
let g:exPJ_window_width_increment = 50

" ------------------------------------------------------------------ 
" Desc: exBufExplorer 
" ------------------------------------------------------------------ 

nnoremap <unique> <silent> <leader>bs :EXBufExplorer<CR>
nnoremap <unique> <leader>bk :EXAddBookmarkDirectly<CR>

let g:exBE_backto_editbuf = 0
let g:exBE_close_when_selected = 0

" ------------------------------------------------------------------ 
" Desc: exMarksBrowser 
" ------------------------------------------------------------------ 

nnoremap <unique> <leader>ms :ExmbToggle<CR>

let g:exMB_backto_editbuf = 0
let g:exMB_close_when_selected = 0
let g:exMB_window_direction = 'bel'

" ------------------------------------------------------------------ 
" Desc: exEnvironmentSetting
" NOTE: The exEnvironmentSetting must put at the end of the plugin 
"       settings. It may update the default settings of plugin above
" ------------------------------------------------------------------ 

let g:exES_project_cmd = 'EXProject'

" exEnvironmentSetting post update
" NOTE: this is a post update environment function used for any custom environment update 
function g:exES_PostUpdate()

    " set lookup file plugin variables
    if exists( 'g:exES_LookupFileTag' )
        let g:LookupFile_TagExpr='"'.g:exES_LookupFileTag.'"'
        if exists(':LUCurFile')
            " NOTE: the second <CR>, if only one file, will jump to it directly.
            unmap gf
            nnoremap <unique> <silent> gf :LUCurFile<CR>
        endif
    endif

    " set visual_studio plugin variables
    if exists( 'g:exES_vsTaskList' )
        let g:visual_studio_task_list = g:exES_vsTaskList
    endif
    if exists( 'g:exES_vsOutput' )
        let g:visual_studio_output = g:exES_vsOutput
    endif
    if exists( 'g:exES_vsFindResult1' )
        let g:visual_studio_find_results_1 = g:exES_vsFindResult1
    endif
    if exists( 'g:exES_vsFindResult2' )
        let g:visual_studio_find_results_2 = g:exES_vsFindResult2
    endif

    " set vimwiki
    if exists( 'g:exES_wikiHome' )
        " clear the list first
        if exists( 'g:vimwiki_list' ) && !empty(g:vimwiki_list)
            silent call remove( g:vimwiki_list, 0, len(g:vimwiki_list)-1 )
        endif

        " assign vimwiki pathes, 
        " NOTE: vimwiki need full path.
        let g:vimwiki_list = [ { 'path': fnamemodify(g:exES_wikiHome,":p"), 
                    \ 'path_html': fnamemodify(g:exES_wikiHomeHtml,":p"),
                    \ 'html_header': fnamemodify(g:exES_wikiHtmlHeader,":p") } ]

        " create vimwiki files
        call exUtility#CreateVimwikiFiles ()
    endif
endfunction

" ------------------------------------------------------------------ 
" Desc: TagList
" ------------------------------------------------------------------ 

" F4:  Switch on/off TagList
nnoremap <unique> <silent> <F4> :TlistToggle<CR>

"let Tlist_Ctags_Cmd = $VIM.'/vimfiles/ctags.exe' " location of ctags tool 
let Tlist_Show_One_File = 1 " Displaying tags for only one file~
let Tlist_Exist_OnlyWindow = 1 " if you are the last, kill yourself 
let Tlist_Use_Right_Window = 1 " split to the right side of the screen 
let Tlist_Sort_Type = "order" " sort by order or name
let Tlist_Display_Prototype = 0 " do not show prototypes and not tags in the taglist window.
let Tlist_Compart_Format = 1 " Remove extra information and blank lines from the taglist window.
let Tlist_GainFocus_On_ToggleOpen = 1 " Jump to taglist window on open.
let Tlist_Display_Tag_Scope = 1 " Show tag scope next to the tag name.
let Tlist_Close_On_Select = 0 " Close the taglist window when a file or tag is selected.
let Tlist_BackToEditBuffer = 0 " If no close on select, let the user choose back to edit buffer or not
let Tlist_Enable_Fold_Column = 0 " Don't Show the fold indicator column in the taglist window.
let Tlist_WinWidth = 40
let Tlist_Compact_Format = 1 " do not show help
" let Tlist_Ctags_Cmd = 'ctags --c++-kinds=+p --fields=+iaS --extra=+q --languages=c++'
" very slow, so I disable this
" let Tlist_Process_File_Always = 1 " To use the :TlistShowTag and the :TlistShowPrototype commands without the taglist window and the taglist menu, you should set this variable to 1.
":TlistShowPrototype [filename] [linenumber]

" let taglist support shader language as c-like language
let tlist_hlsl_settings = 'c;d:macro;g:enum;s:struct;u:union;t:typedef;v:variable;f:function'

" ------------------------------------------------------------------ 
" Desc: MiniBufExpl
" ------------------------------------------------------------------ 

let g:miniBufExplTabWrap = 1 " make tabs show complete (no broken on two lines) 
let g:miniBufExplModSelTarget = 1 " If you use other explorers like TagList you can (As of 6.2.8) set it at 1:
let g:miniBufExplUseSingleClick = 1 " If you would like to single click on tabs rather than double clicking on them to goto the selected buffer. 
let g:miniBufExplMaxSize = 1 " <max lines: default 0> setting this to 0 will mean the window gets as big as needed to fit all your buffers. 
" comment out this, when we open a single file by we, we don't need minibuf opened. Minibu always open in exdev mode, in EnvironmentUpdate 
" let g:miniBufExplorerMoreThanOne = 0 " Setting this to 0 will cause the MBE window to be loaded even

"let g:miniBufExplForceSyntaxEnable = 1 " There is a VIM bug that can cause buffers to show up without their highlighting. The following setting will cause MBE to
"let g:miniBufExplMapCTabSwitchBufs = 1 
"let g:miniBufExplMapWindowNavArrows = 1

" ------------------------------------------------------------------ 
" Desc: OmniCppComplete
" ------------------------------------------------------------------ 

" set Ctrl+j in insert mode, like VS.Net
imap <unique> <C-j> <C-X><C-O>
" :inoremap <expr> <cr> pumvisible() ? "\<c-y>" : "\<c-g>u\<cr>" 

" set completeopt as don't show menu and preview
au FileType c,cpp,hlsl set completeopt=menuone

" use global scope search
let OmniCpp_GlobalScopeSearch = 1

" 0 = namespaces disabled
" 1 = search namespaces in the current buffer
" 2 = search namespaces in the current buffer and in included files
let OmniCpp_NamespaceSearch = 1

" 0 = auto
" 1 = always show all members
let OmniCpp_DisplayMode = 1

" 0 = don't show scope in abbreviation
" 1 = show scope in abbreviation and remove the last column
let OmniCpp_ShowScopeInAbbr = 0

" This option allows to display the prototype of a function in the abbreviation part of the popup menu.
" 0 = don't display prototype in abbreviation
" 1 = display prototype in abbreviation
let OmniCpp_ShowPrototypeInAbbr = 1

" This option allows to show/hide the access information ('+', '#', '-') in the popup menu.
" 0 = hide access
" 1 = show access
let OmniCpp_ShowAccess = 1

" This option can be use if you don't want to parse using namespace declarations in included files and want to add namespaces that are always used in your project.
let OmniCpp_DefaultNamespaces = ["std"]

" Complete Behaviour
let OmniCpp_MayCompleteDot = 0
let OmniCpp_MayCompleteArrow = 0
let OmniCpp_MayCompleteScope = 0

" When 'completeopt' does not contain "longest", Vim automatically select the first entry of the popup menu. You can change this behaviour with the OmniCpp_SelectFirstItem option.
let OmniCpp_SelectFirstItem = 0

" ------------------------------------------------------------------ 
" Desc: pythoncomplete
" ------------------------------------------------------------------ 

" DISABLE: au FileType python set completeopt=menuone,preview
" NOTE: the preview can show the internal document in a preview window, but I don't think it have too much help
au FileType python set completeopt=menuone

" ------------------------------------------------------------------ 
" Desc: EnhCommentify
" ------------------------------------------------------------------ 

let g:EnhCommentifyFirstLineMode='yes'
let g:EnhCommentifyRespectIndent='yes'
let g:EnhCommentifyUseBlockIndent='yes'
let g:EnhCommentifyAlignRight = 'yes'
let g:EnhCommentifyPretty = 'yes'
let g:EnhCommentifyBindInNormal = 'no'
let g:EnhCommentifyBindInVisual = 'no'
let g:EnhCommentifyBindInInsert = 'no'

" NOTE: VisualComment,Comment,DeComment are plugin mapping(start with <Plug>), so can't use remap here
vmap <unique> <F11> <Plug>VisualComment
nmap <unique> <F11> <Plug>Comment
imap <unique> <F11> <ESC><Plug>Comment
vmap <unique> <C-F11> <Plug>VisualDeComment
nmap <unique> <C-F11> <Plug>DeComment
imap <unique> <C-F11> <ESC><Plug>DeComment

" ======================================================== 
"  add new languages for comment
" ======================================================== 

function EnhCommentifyCallback(ft)
    " for hlsl, swig, c
    if a:ft =~ '^\(hlsl\|swig\|c\)$' " NOTE: we have to rewrite the c comment behavior. 
        let b:ECcommentOpen = '//'
        let b:ECcommentClose = ''
    elseif a:ft == 'snippet' " for snippet
        let b:ECcommentOpen = '#'
        let b:ECcommentClose = ''
    elseif a:ft == 'maxscript' " for maxscript
        let b:ECcommentOpen = '--'
        let b:ECcommentClose = ''
    endif
endfunction
let g:EnhCommentifyCallbackExists = 'Yes'

" ------------------------------------------------------------------ 
" Desc: ShowMarks
" ------------------------------------------------------------------ 

let g:showmarks_enable = 1
let showmarks_include = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
" Ignore help, quickfix, non-modifiable buffers
let showmarks_ignore_type = "hqm"
" Hilight lower & upper marks
let showmarks_hlline_lower = 1
let showmarks_hlline_upper = 0 

" ------------------------------------------------------------------ 
" Desc: LookupFile 
" ------------------------------------------------------------------ 

nnoremap <unique> <leader>lf :LUTags<CR>
nnoremap <unique> <leader>lb :LUBufs<CR>
nnoremap <unique> <silent> <Leader>ll :LUCurWord<CR>

let g:LookupFile_TagExpr = ''
let g:LookupFile_MinPatLength = 3
let g:LookupFile_PreservePatternHistory = 0
let g:LookupFile_PreserveLastPattern = 0
let g:LookupFile_AllowNewFiles = 0
let g:LookupFile_smartcase = 1
let g:LookupFile_EscCancelsPopup = 1

" ------------------------------------------------------------------ 
" Desc: VimWiki 
" ------------------------------------------------------------------ 

" vimwiki file process
au FileType vimwiki command! W call exUtility#SaveAndConvertVimwiki(0)
au FileType vimwiki command! WA call exUtility#SaveAndConvertVimwiki(1)
au FileType rst command! W call exUtility#SphinxMake('html')

let g:vimwiki_camel_case = 0
let g:vimwiki_hl_headers = 1

" ------------------------------------------------------------------ 
" Desc: snipMate
" ------------------------------------------------------------------ 

let g:snips_author = g:ex_usr_name
let g:snippets_dir = g:ex_toolkit_path . '/snippets/'

" ------------------------------------------------------------------ 
" Desc: NERD_tree 
" ------------------------------------------------------------------ 

let g:NERDTreeWinSize = exists('g:exPJ_window_width') ? g:exPJ_window_width : 30 

" ------------------------------------------------------------------ 
" Desc: zencoding 
" ------------------------------------------------------------------ 

let g:user_zen_leader_key = '<c-j>'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Remmapping bépo
source ~/.vim/bepo.vimrc

""" Mutt
augroup filetypedetect
    autocmd BufRead,BufNewfile *mutt-*  setfiletype mail
augroup END


map <F7> :setlocal spell! spelllang=fr,en<CR>
map <F6> :set expandtab!<CR>
